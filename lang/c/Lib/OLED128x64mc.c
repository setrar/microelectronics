// OLED128x64.c
//   128x64 OLED display using I2C
//    
// Ted Rossin
// 01-12-2018
// 08-23-2022

#include "pico/stdlib.h"
#include "hardware/i2c.h"
#include "pico/multicore.h"
#include "OLED128x64mc.h"

#define FONT_WIDTH0	    6
#define FONT_HEIGHT0 	8

const uint8_t Font0[] = {
     0xaa,0x55,0xaa,0x55,0xaa  // 0x00
    ,0x00,0x00,0x00,0x00,0x00  // 0x01
    ,0x00,0x00,0x00,0x00,0x00  // 0x02
    ,0x00,0x00,0x00,0x00,0x00  // 0x03
    ,0x00,0x00,0x00,0x00,0x00  // 0x04
    ,0x00,0x00,0x00,0x00,0x00  // 0x05
    ,0x00,0x00,0x00,0x00,0x00  // 0x06
    ,0x00,0x00,0x00,0x00,0x00  // 0x07
    ,0x00,0x00,0x00,0x00,0x00  // 0x08
    ,0x00,0x00,0x00,0x00,0x00  // 0x09
    ,0x00,0x00,0x00,0x00,0x00  // 0x0A
    ,0x00,0x00,0x00,0x00,0x00  // 0x0B
    ,0x00,0x00,0x00,0x00,0x00  // 0x0C
    ,0x00,0x00,0x00,0x00,0x00  // 0x0D
    ,0x00,0x00,0x00,0x00,0x00  // 0x0E
    ,0x00,0x00,0x00,0x00,0x00  // 0x0F
    ,0x00,0x00,0x00,0x00,0x00  // 0x10
    ,0x00,0x00,0x00,0x00,0x00  // 0x11
    ,0x00,0x00,0x00,0x00,0x00  // 0x12
    ,0x00,0x00,0x00,0x00,0x00  // 0x13
    ,0x00,0x00,0x00,0x00,0x00  // 0x14
    ,0x00,0x00,0x00,0x00,0x00  // 0x15
    ,0x00,0x00,0x00,0x00,0x00  // 0x16
    ,0x00,0x00,0x00,0x00,0x00  // 0x17
    ,0x00,0x00,0x00,0x00,0x00  // 0x18
    ,0x00,0x00,0x00,0x00,0x00  // 0x19
    ,0x00,0x00,0x00,0x00,0x00  // 0x1A
    ,0x00,0x00,0x00,0x00,0x00  // 0x1B
    ,0x00,0x00,0x00,0x00,0x00  // 0x1C
    ,0x00,0x00,0x00,0x00,0x00  // 0x1D
    ,0x00,0x00,0x00,0x00,0x00  // 0x1E
    ,0x00,0x00,0x00,0x00,0x00  // 0x1F
    ,0x00,0x00,0x00,0x00,0x00  // 0x20
    ,0x00,0x00,0x7D,0x00,0x00  // 0x21
    ,0x00,0x30,0x00,0x30,0x00  // 0x22
    ,0x14,0x7F,0x14,0x7F,0x14  // 0x23
    ,0x12,0x2A,0x7F,0x2A,0x24  // 0x24
    ,0x32,0x34,0x08,0x13,0x23  // 0x25
    ,0x36,0x49,0x55,0x22,0x05  // 0x26
    ,0x00,0x00,0x70,0x00,0x00  // 0x27
    ,0x00,0x1C,0x22,0x41,0x00  // 0x28
    ,0x00,0x41,0x22,0x1C,0x00  // 0x29
    ,0x14,0x08,0x3E,0x08,0x14  // 0x2A
    ,0x08,0x08,0x3E,0x08,0x08  // 0x2B
    ,0x00,0x05,0x06,0x00,0x00  // 0x2C
    ,0x08,0x08,0x08,0x08,0x08  // 0x2D
    ,0x00,0x03,0x03,0x00,0x00  // 0x2E
    ,0x02,0x04,0x08,0x10,0x20  // 0x2F
    ,0x3E,0x45,0x49,0x51,0x3E  // 0x30
    ,0x00,0x21,0x7F,0x01,0x00  // 0x31
    ,0x21,0x43,0x45,0x49,0x31  // 0x32
    ,0x42,0x41,0x51,0x69,0x46  // 0x33
    ,0x0C,0x14,0x24,0x7F,0x04  // 0x34
    ,0x72,0x51,0x51,0x51,0x4E  // 0x35
    ,0x1E,0x29,0x49,0x49,0x06  // 0x36
    ,0x60,0x40,0x47,0x48,0x70  // 0x37
    ,0x36,0x49,0x49,0x49,0x36  // 0x38
    ,0x30,0x49,0x49,0x4A,0x3C  // 0x39
    ,0x00,0x36,0x36,0x00,0x00  // 0x3A
    ,0x00,0x35,0x36,0x00,0x00  // 0x3B
    ,0x08,0x14,0x22,0x41,0x00  // 0x3C
    ,0x14,0x14,0x14,0x14,0x14  // 0x3D
    ,0x00,0x41,0x22,0x14,0x08  // 0x3E
    ,0x20,0x40,0x45,0x48,0x30  // 0x3F
    ,0x26,0x49,0x4F,0x41,0x3E  // 0x40
    ,0x3F,0x48,0x48,0x48,0x3F  // 0x41
    ,0x7F,0x49,0x49,0x49,0x36  // 0x42
    ,0x3E,0x41,0x41,0x41,0x22  // 0x43
    ,0x7F,0x41,0x41,0x22,0x1C  // 0x44
    ,0x7F,0x49,0x49,0x49,0x41  // 0x45
    ,0x7F,0x48,0x48,0x48,0x40  // 0x46
    ,0x3E,0x41,0x49,0x49,0x2F  // 0x47
    ,0x7F,0x08,0x08,0x08,0x7F  // 0x48
    ,0x00,0x41,0x7F,0x41,0x00  // 0x49
    ,0x02,0x01,0x41,0x7F,0x40  // 0x4A
    ,0x7F,0x08,0x14,0x22,0x41  // 0x4B
    ,0x7F,0x01,0x01,0x01,0x01  // 0x4C
    ,0x7F,0x20,0x18,0x20,0x7F  // 0x4D
    ,0x7F,0x10,0x08,0x04,0x7F  // 0x4E
    ,0x3E,0x41,0x41,0x41,0x3E  // 0x4F
    ,0x7F,0x48,0x48,0x48,0x30  // 0x50
    ,0x3E,0x41,0x45,0x42,0x3D  // 0x51
    ,0x7F,0x48,0x4C,0x4A,0x31  // 0x52
    ,0x31,0x49,0x49,0x49,0x46  // 0x53
    ,0x40,0x40,0x7F,0x40,0x40  // 0x54
    ,0x7E,0x01,0x01,0x01,0x7E  // 0x55
    ,0x7C,0x02,0x01,0x02,0x7C  // 0x56
    ,0x7E,0x01,0x0E,0x01,0x7E  // 0x57
    ,0x63,0x14,0x08,0x14,0x63  // 0x58
    ,0x70,0x08,0x07,0x08,0x70  // 0x59
    ,0x43,0x45,0x49,0x51,0x61  // 0x5A
    ,0x7F,0x41,0x41,0x00,0x00  // 0x5B
    ,0x20,0x10,0x08,0x04,0x02  // 0x5C
    ,0x00,0x00,0x41,0x41,0x7F  // 0x5D
    ,0x10,0x20,0x40,0x20,0x10  // 0x5E
    ,0x01,0x01,0x01,0x01,0x01  // 0x5F
    ,0x40,0x20,0x10,0x00,0x00  // 0x60
    ,0x02,0x15,0x15,0x15,0x0F  // 0x61
    ,0x7F,0x11,0x11,0x11,0x0E  // 0x62
    ,0x0E,0x11,0x11,0x11,0x00  // 0x63
    ,0x0E,0x11,0x11,0x11,0x7F  // 0x64
    ,0x0E,0x15,0x15,0x15,0x0C  // 0x65
    ,0x00,0x08,0x3F,0x48,0x20  // 0x66
    ,0x18,0x25,0x25,0x29,0x1E  // 0x67
    ,0x7F,0x10,0x10,0x10,0x0F  // 0x68
    ,0x00,0x00,0x2F,0x00,0x00  // 0x69
    ,0x00,0x02,0x01,0x01,0x2E  // 0x6A
    ,0x7F,0x04,0x0A,0x11,0x00  // 0x6B
    ,0x00,0x21,0x3F,0x01,0x00  // 0x6C
    ,0x1F,0x10,0x0F,0x10,0x1F  // 0x6D
    ,0x0F,0x10,0x10,0x10,0x0F  // 0x6E
    ,0x0E,0x11,0x11,0x11,0x0E  // 0x6F
    ,0x1F,0x24,0x24,0x24,0x18  // 0x70
    ,0x18,0x24,0x24,0x1F,0x01  // 0x71
    ,0x1F,0x08,0x10,0x10,0x08  // 0x72
    ,0x08,0x15,0x15,0x15,0x02  // 0x73
    ,0x00,0x10,0x3F,0x11,0x00  // 0x74
    ,0x00,0x1E,0x01,0x01,0x1E  // 0x75
    ,0x1C,0x02,0x01,0x02,0x1C  // 0x76
    ,0x1E,0x01,0x06,0x01,0x1E  // 0x77
    ,0x11,0x0A,0x04,0x0A,0x11  // 0x78
    ,0x00,0x18,0x05,0x06,0x18  // 0x79
    ,0x11,0x13,0x15,0x19,0x11  // 0x7A
    ,0x00,0x08,0x36,0x41,0x00  // 0x7B
    ,0x00,0x00,0x7F,0x00,0x00  // 0x7C
    ,0x00,0x41,0x36,0x08,0x00  // 0x7D
    ,0x08,0x10,0x08,0x04,0x08  // 0x7E
    ,0x00,0x00,0x00,0x00,0x00  // 0x7F
};

#define FONT_WIDTH1  	12
#define FONT_HEIGHT1	16

const uint16_t Font1[] = {
/*
     0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x00
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x01
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x02
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x03
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x04
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x05
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x06
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x07
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x08
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x09
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x0A
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x0B
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x0C
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x0D
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x0E
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x0F
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x10
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x11
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x12
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x13
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x14
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x15
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x16
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x17
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x18
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x19
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x1A
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x1B
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x1C
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x1D
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x1E
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x1F
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x20
*/    
     0x0000,0x0000,0x0000,0x0000,0x0000,0x7FF3,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x21
    ,0x0000,0x0000,0x0000,0x7800,0x0000,0x0000,0x0000,0x7800,0x0000,0x0000,0x0000  // 0x22
    ,0x0410,0x0410,0x0410,0x7FFF,0x0410,0x0410,0x0410,0x7FFF,0x0410,0x0410,0x0410  // 0x23
    ,0x0E08,0x1104,0x2082,0x7FFF,0x2082,0x2082,0x2082,0x7FFF,0x2082,0x1044,0x0838  // 0x24
    ,0x1C04,0x2208,0x2210,0x2220,0x1C40,0x0080,0x011C,0x0222,0x0422,0x0822,0x101C  // 0x25
    ,0x1C1C,0x2222,0x4141,0x4081,0x4141,0x2221,0x1C11,0x000A,0x0004,0x000A,0x0001  // 0x26
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x7C00,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x27
    ,0x0000,0x0000,0x0000,0x07F0,0x180C,0x2002,0x4001,0x0000,0x0000,0x0000,0x0000  // 0x28
    ,0x0000,0x0000,0x0000,0x0000,0x4001,0x2002,0x180C,0x07F0,0x0000,0x0000,0x0000  // 0x29
    ,0x0000,0x0000,0x0410,0x0220,0x0140,0x1FFC,0x0140,0x0220,0x0410,0x0000,0x0000  // 0x2A
    ,0x0000,0x0080,0x0080,0x0080,0x0080,0x0FF8,0x0080,0x0080,0x0080,0x0080,0x0000  // 0x2B
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x000D,0x000E,0x0000,0x0000,0x0000,0x0000  // 0x2C
    ,0x0000,0x0000,0x0080,0x0080,0x0080,0x0080,0x0080,0x0080,0x0080,0x0000,0x0000  // 0x2D
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0003,0x0003,0x0000,0x0000,0x0000,0x0000  // 0x2E
    ,0x0004,0x0008,0x0010,0x0020,0x0040,0x0080,0x0100,0x0200,0x0400,0x0800,0x1000  // 0x2F
    ,0x0000,0x1FFC,0x2002,0x4001,0x4001,0x41C1,0x4001,0x4001,0x2002,0x1FFC,0x0000  // 0x30
    ,0x0000,0x0000,0x0001,0x1001,0x2001,0x7FFF,0x0001,0x0001,0x0001,0x0000,0x0000  // 0x31
    ,0x1801,0x2003,0x4005,0x4009,0x4011,0x4021,0x4041,0x4081,0x4101,0x2201,0x1C01  // 0x32
    ,0x180C,0x2002,0x4001,0x4001,0x4001,0x4081,0x4081,0x4081,0x4081,0x2142,0x1E3C  // 0x33
    ,0x0080,0x0180,0x0280,0x0480,0x0880,0x1080,0x2080,0x7FFF,0x0080,0x0080,0x0080  // 0x34
    ,0x7F04,0x4102,0x4101,0x4101,0x4101,0x4101,0x4101,0x4101,0x4101,0x4082,0x407C  // 0x35
    ,0x1FFC,0x2082,0x4081,0x4081,0x4081,0x4081,0x4081,0x4081,0x4081,0x2042,0x183C  // 0x36
    ,0x4000,0x4000,0x4000,0x4000,0x4000,0x407F,0x4080,0x4100,0x4200,0x4400,0x7800  // 0x37
    ,0x1E3C,0x2142,0x4081,0x4081,0x4081,0x4081,0x4081,0x4081,0x4081,0x2142,0x1E3C  // 0x38
    ,0x1E0C,0x2102,0x4081,0x4081,0x4081,0x4081,0x4081,0x4081,0x4081,0x2082,0x1FFC  // 0x39
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0630,0x0630,0x0000,0x0000,0x0000,0x0000  // 0x3A
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0634,0x0638,0x0000,0x0000,0x0000,0x0000  // 0x3B
    ,0x0000,0x0000,0x0080,0x0140,0x0220,0x0410,0x0808,0x1004,0x2002,0x0000,0x0000  // 0x3C
    ,0x0000,0x0000,0x0210,0x0210,0x0210,0x0210,0x0210,0x0210,0x0210,0x0000,0x0000  // 0x3D
    ,0x0000,0x0000,0x2002,0x1004,0x0808,0x0410,0x0220,0x0140,0x0080,0x0000,0x0000  // 0x3E
    ,0x1C00,0x2200,0x4000,0x4000,0x4000,0x403B,0x4040,0x4080,0x4100,0x2200,0x1C00  // 0x3F
    ,0x1FFC,0x2002,0x4181,0x4241,0x4421,0x4421,0x4241,0x47F1,0x4011,0x2012,0x1FE4  // 0x40
    ,0x0FFF,0x1080,0x2080,0x4080,0x4080,0x4080,0x4080,0x4080,0x2080,0x1080,0x0FFF  // 0x41
    ,0x7FFF,0x4081,0x4081,0x4081,0x4081,0x4081,0x4081,0x4081,0x4081,0x2142,0x1E3C  // 0x42
    ,0x1FFC,0x2002,0x4001,0x4001,0x4001,0x4001,0x4001,0x4001,0x4001,0x2002,0x180C  // 0x43
    ,0x7FFF,0x4001,0x4001,0x4001,0x4001,0x4001,0x4001,0x4001,0x4001,0x2002,0x1FFC  // 0x44
    ,0x7FFF,0x4081,0x4081,0x4081,0x4081,0x4081,0x4081,0x4001,0x4001,0x4001,0x4001  // 0x45
    ,0x7FFF,0x4080,0x4080,0x4080,0x4080,0x4080,0x4080,0x4000,0x4000,0x4000,0x4000  // 0x46
    ,0x1FFC,0x2002,0x4001,0x4001,0x4001,0x4001,0x4001,0x4041,0x4041,0x2042,0x187C  // 0x47
    ,0x7FFF,0x0080,0x0080,0x0080,0x0080,0x0080,0x0080,0x0080,0x0080,0x0080,0x7FFF  // 0x48
    ,0x0000,0x0000,0x4001,0x4001,0x4001,0x7FFF,0x4001,0x4001,0x4001,0x0000,0x0000  // 0x49
    ,0x0004,0x0002,0x0001,0x0001,0x0001,0x0001,0x4001,0x4001,0x4001,0x4002,0x7FFC  // 0x4A
    ,0x7FFF,0x0080,0x0080,0x0080,0x0140,0x0220,0x0410,0x0808,0x1004,0x2002,0x4001  // 0x4B
    ,0x7FFF,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0003  // 0x4C
    ,0x7FFF,0x2000,0x1000,0x0800,0x0400,0x0200,0x0400,0x0800,0x1000,0x2000,0x7FFF  // 0x4D
    ,0x7FFF,0x0800,0x0400,0x0200,0x0100,0x0080,0x0040,0x0020,0x0010,0x0008,0x7FFF  // 0x4E
    ,0x1FFC,0x2002,0x4001,0x4001,0x4001,0x4001,0x4001,0x4001,0x4001,0x2002,0x1FFC  // 0x4F
    ,0x7FFF,0x4080,0x4080,0x4080,0x4080,0x4080,0x4080,0x4080,0x4080,0x2100,0x1E00  // 0x50
    ,0x1FFC,0x2002,0x4001,0x4001,0x4001,0x4001,0x4001,0x4009,0x4005,0x2002,0x1FFD  // 0x51
    ,0x7FFF,0x4080,0x4080,0x4080,0x40C0,0x40A0,0x4090,0x4088,0x4084,0x2102,0x1E01  // 0x52
    ,0x1E04,0x2102,0x4081,0x4081,0x4081,0x4081,0x4081,0x4081,0x4081,0x2042,0x103C  // 0x53
    ,0x4000,0x4000,0x4000,0x4000,0x4000,0x7FFF,0x4000,0x4000,0x4000,0x4000,0x4000  // 0x54
    ,0x7FFC,0x0002,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0002,0x7FFC  // 0x55
    ,0x7FE0,0x0010,0x0008,0x0004,0x0002,0x0001,0x0002,0x0004,0x0008,0x0010,0x7FE0  // 0x56
    ,0x7FFF,0x0002,0x0004,0x0008,0x0010,0x0020,0x0010,0x0008,0x0004,0x0002,0x7FFF  // 0x57
    ,0x7007,0x0808,0x0410,0x0220,0x0140,0x0080,0x0140,0x0220,0x0410,0x0808,0x7007  // 0x58
    ,0x7000,0x0800,0x0400,0x0200,0x0100,0x00FF,0x0100,0x0200,0x0400,0x0800,0x7000  // 0x59
    ,0x4007,0x4009,0x4011,0x4021,0x4041,0x4081,0x4101,0x4201,0x4401,0x4801,0x7001  // 0x5A
    ,0x0000,0x0000,0x0000,0x0000,0x7FFF,0x4001,0x4001,0x4001,0x0000,0x0000,0x0000  // 0x5B
    ,0x1000,0x0800,0x0400,0x0200,0x0100,0x0080,0x0040,0x0020,0x0010,0x0008,0x0004  // 0x5C
    ,0x0000,0x0000,0x0000,0x4001,0x4001,0x4001,0x7FFF,0x0000,0x0000,0x0000,0x0000  // 0x5D
    ,0x0000,0x0000,0x0800,0x1000,0x2000,0x4000,0x2000,0x1000,0x0800,0x0000,0x0000  // 0x5E
    ,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001  // 0x5F
    ,0x0000,0x0000,0x0000,0x4000,0x2000,0x1000,0x0800,0x0000,0x0000,0x0000,0x0000  // 0x60
    ,0x0006,0x0009,0x0091,0x0091,0x0091,0x0091,0x0091,0x0091,0x0091,0x0051,0x003F  // 0x61
    ,0x7FFF,0x0081,0x0081,0x0081,0x0081,0x0081,0x0081,0x0081,0x0081,0x0042,0x003C  // 0x62
    ,0x003C,0x0042,0x0081,0x0081,0x0081,0x0081,0x0081,0x0081,0x0081,0x0081,0x0042  // 0x63
    ,0x003C,0x0042,0x0081,0x0081,0x0081,0x0081,0x0081,0x0081,0x0081,0x0081,0x7FFF  // 0x64
    ,0x003C,0x0052,0x0091,0x0091,0x0091,0x0091,0x0091,0x0091,0x0091,0x0051,0x0032  // 0x65
    ,0x0000,0x0000,0x0080,0x0080,0x1FFF,0x2080,0x4080,0x4080,0x2000,0x1800,0x0000  // 0x66
    ,0x00E0,0x0112,0x0209,0x0209,0x0209,0x0209,0x0209,0x0209,0x0209,0x010A,0x00FC  // 0x67
    ,0x7FFF,0x0020,0x0040,0x0080,0x0080,0x0080,0x0080,0x0080,0x0080,0x0040,0x003F  // 0x68
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x02FF,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x69
    ,0x0000,0x0000,0x0002,0x0001,0x0001,0x0001,0x0001,0x0001,0x0002,0x0BFC,0x0000  // 0x6A
    ,0x7FFF,0x0020,0x0020,0x0020,0x0020,0x0020,0x0050,0x0088,0x0104,0x0202,0x0401  // 0x6B
    ,0x0000,0x0000,0x0000,0x0000,0x4001,0x7FFF,0x0001,0x0000,0x0000,0x0000,0x0000  // 0x6C
    ,0x003F,0x0040,0x0080,0x0080,0x0040,0x003F,0x0040,0x0080,0x0080,0x0040,0x003F  // 0x6D
    ,0x0000,0x0000,0x01FF,0x0080,0x0100,0x0100,0x0100,0x0080,0x007F,0x0000,0x0000  // 0x6E
    ,0x003C,0x0042,0x0081,0x0081,0x0081,0x0081,0x0081,0x0081,0x0081,0x0042,0x003C  // 0x6F
    ,0x00FF,0x0108,0x0204,0x0204,0x0204,0x0204,0x0204,0x0204,0x0108,0x00F0,0x0000  // 0x70
    ,0x00F0,0x0108,0x0204,0x0204,0x0204,0x0204,0x0204,0x0204,0x0108,0x03FF,0x0000  // 0x71
    ,0x00FF,0x0020,0x0040,0x0080,0x0080,0x0080,0x0080,0x0080,0x0080,0x0040,0x0020  // 0x72
    ,0x00E2,0x0111,0x0111,0x0111,0x0111,0x0111,0x0111,0x0111,0x0111,0x0111,0x008E  // 0x73
    ,0x0080,0x0080,0x0080,0x0080,0x03FC,0x0082,0x0081,0x0081,0x0081,0x0002,0x0000  // 0x74
    ,0x00FC,0x0002,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0002,0x00FC  // 0x75
    ,0x00E0,0x0010,0x0008,0x0004,0x0002,0x0001,0x0002,0x0004,0x0008,0x0010,0x00E0  // 0x76
    ,0x00F8,0x0004,0x0002,0x0001,0x0002,0x001C,0x0002,0x0001,0x0002,0x0004,0x00F8  // 0x77
    ,0x0000,0x0101,0x0082,0x0044,0x0028,0x0010,0x0028,0x0044,0x0082,0x0101,0x0000  // 0x78
    ,0x0000,0x0000,0x0081,0x0041,0x0022,0x0014,0x0008,0x0010,0x0020,0x0040,0x0080  // 0x79
    ,0x0000,0x0083,0x0085,0x0085,0x0089,0x0089,0x0091,0x0091,0x00A1,0x00A1,0x00C1  // 0x7A
    ,0x0000,0x0000,0x0080,0x0140,0x0E38,0x3006,0x4001,0x0000,0x0000,0x0000,0x0000  // 0x7B
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x7FFF,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x7C
    ,0x0000,0x0000,0x0000,0x0000,0x4001,0x3006,0x0E38,0x0140,0x0080,0x0000,0x0000  // 0x7D
    ,0x0000,0x0000,0x0800,0x1000,0x2000,0x1000,0x0800,0x0400,0x0800,0x1000,0x0000  // 0x7E
    ,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000  // 0x7F
};

    // A bit ugly since the api does not seem to allow sending data without a start (or with an end)
uint8_t RawBuffer0[DISP_WIDTH*DISP_HEIGHT/8+1];
uint8_t RawBuffer1[DISP_WIDTH*DISP_HEIGHT/8+1];
uint8_t *FrameBuffer = &RawBuffer0[1]; 
uint8_t *DisplayBuffer = &RawBuffer1[1];

static uint8_t gfColor = 1;
static uint8_t gfFill = 0;
static uint8_t gfFontId = 0;
static uint8_t FONT_WIDTH = FONT_WIDTH0;
static uint8_t FONT_HEIGHT = FONT_HEIGHT0;
static uint8_t gfFont2X = 0;

#define SLAVE_ADDR  (0x78>>1)   // i2c_write uses non-shifted address (0x78 is what is on the silk-screen)

#define SEND_STOP       0
#define DONT_SEND_STOP  1

#define SWAP_BUFFER_CLEAR_TO_0 10
#define SWAP_BUFFER_CLEAR_TO_1 11

void I2cInit(void)
{
        // See page 216 of Harry FairHead's book on PICO in C
        // Set up SDA to be GPIO4, and SCL to be GPIO5 (could be 0/1, 4/5, 8/9,12/13,16/17,20/21, 28/x)
#ifdef SEEED_PICO
    i2c_init(i2c1,2000*1000); // N MHz baud rate
    gpio_set_function(6,GPIO_FUNC_I2C);
    gpio_set_function(7,GPIO_FUNC_I2C);
#else
    i2c_init(i2c0,2000*1000); // N MHz baud rate
    gpio_set_function(4,GPIO_FUNC_I2C);
    gpio_set_function(5,GPIO_FUNC_I2C);
#endif    
}

static void SwapDisplayBuffer(uint8_t Color);

static uint8_t ClearColor = 0x00;

static void core1_entry() 
{
    static uint32_t Command;

    while(1){
        Command = multicore_fifo_pop_blocking();
        switch(Command){
            case SWAP_BUFFER_CLEAR_TO_0:
                SwapDisplayBuffer(0);
                break;
            case SWAP_BUFFER_CLEAR_TO_1:
                SwapDisplayBuffer(1);
                break;
        }
        multicore_fifo_push_blocking(0); 
    }
}

static uint8_t gfUpdateDisplay(uint8_t ClearBuffer)
{
    uint16_t Index;
    uint8_t *ptr = DisplayBuffer;

#ifdef SEEED_PICO
    if(i2c_write_blocking(i2c1,SLAVE_ADDR,ptr-1,DISP_WIDTH*DISP_HEIGHT/8+1,SEND_STOP)!=(DISP_WIDTH*DISP_HEIGHT/8)+1) return(0xff);

#else
    if(i2c_write_blocking(i2c0,SLAVE_ADDR,ptr-1,DISP_WIDTH*DISP_HEIGHT/8+1,SEND_STOP)!=(DISP_WIDTH*DISP_HEIGHT/8)+1) return(0xff);
#endif
    if(ClearBuffer){
        if(ClearColor==1){
            for(Index=0;Index<DISP_WIDTH*DISP_HEIGHT/8;Index++) *ptr++ = 0xff;
        }
        else{
            for(Index=0;Index<DISP_WIDTH*DISP_HEIGHT/8;Index++) *ptr++ = 0x00;
        }
    }    
    return(0);
}

static void SwapDisplayBuffer(uint8_t Color)
{
    uint8_t *ptr;
    ptr = FrameBuffer;
    FrameBuffer = DisplayBuffer;
    DisplayBuffer = ptr;
    ClearColor = Color;
    gfUpdateDisplay(1);
}

void gfSwapDisplayBuffer(uint8_t Color)
{
    uint32_t ReturnValue;

    ReturnValue = multicore_fifo_pop_blocking();  // wait for previous command
    if(Color==0) multicore_fifo_push_blocking(SWAP_BUFFER_CLEAR_TO_0);
    else         multicore_fifo_push_blocking(SWAP_BUFFER_CLEAR_TO_1);
}

uint8_t SendCmd(uint8_t Val)
{
    uint8_t Buf[2];


    Buf[0] = 0;  // Control {C0,D/C,6'd0}
    Buf[1] = Val;
#ifdef SEEED_PICO
    if(i2c_write_blocking(i2c1,SLAVE_ADDR,Buf,2,SEND_STOP)!=2) return(0xff);
#else
    if(i2c_write_blocking(i2c0,SLAVE_ADDR,Buf,2,SEND_STOP)!=2) return(0xff);
#endif    
	return(0);
}


#define SSD1306_SETCONTRAST 0x81

#define SSD1306_DISPLAYALLON_RESUME 0xA4
#define SSD1306_NORMALDISPLAY 0xA6

#define SSD1306_DISPLAYOFF 0xAE
#define SSD1306_DISPLAYON 0xAF

#define SSD1306_SETDISPLAYOFFSET 0xD3
#define SSD1306_SETCOMPINS 0xDA

#define SSD1306_SETVCOMDETECT 0xDB

#define SSD1306_SETDISPLAYCLOCKDIV 0xD5
#define SSD1306_SETPRECHARGE 0xD9

#define SSD1306_SETMULTIPLEX 0xA8

#define SSD1306_SETLOWCOLUMN 0x00
#define SSD1306_SETHIGHCOLUMN 0x10

#define SSD1306_SETSTARTLINE 0x40

#define SSD1306_MEMORYMODE 0x20
#define SSD1306_COLUMNADDR 0x21
#define SSD1306_PAGEADDR   0x22

#define SSD1306_COMSCANINC 0xC0
#define SSD1306_COMSCANDEC 0xC8

#define SSD1306_SEGREMAP 0xA0

#define SSD1306_CHARGEPUMP 0x8D

#define SSD1306_DEACTIVATE_SCROLL 0x2E

void gfDisplayOLEDInitMC(void) 
{
    I2cInit();
    sleep_ms(20);
	// Started with AdaFruit_SSD1306 library
	
    SendCmd(SSD1306_DISPLAYOFF);                    // 0xae

    SendCmd(SSD1306_CHARGEPUMP);                    // 0x8d
    SendCmd(0x14); 								    // Enable Charge pump (A[2] is the enable)
  
    SendCmd(SSD1306_MEMORYMODE);                    // 0x20
    SendCmd(0x00);                                  // 0x00 act like ks0108 (Horizontal Addressing mode)
    SendCmd(SSD1306_SEGREMAP | 0x1);				// Flip display so column 0 is on the left (col addr 127 mapped to SEG0)
    SendCmd(SSD1306_COMSCANDEC);					// 0xc8 Remapped mode.  Scan from COM[63] to COM[0] (row 63 to row 0)

    SendCmd(SSD1306_SETCOMPINS);                    // 0xda
    SendCmd(0x12);									// Alternative COM pin configuration (reset value)
    SendCmd(SSD1306_SETCONTRAST);                   // 0x81
    SendCmd(0xcf); 								    // Contrast is 0 to 0xff was 0xcf (maybe this can be used to adjust display brightness

    SendCmd(SSD1306_SETPRECHARGE);                  // 0xd9
    SendCmd(0xf1); 									// Phase 2 period is 15 clocks, Phase 1 period is 1
    SendCmd(SSD1306_SETVCOMDETECT);                 // 0xdb
    SendCmd(0x40);									// Not defined in spec but something greater than 0.83*Vcc
    SendCmd(SSD1306_DISPLAYALLON_RESUME);           // 0xa4  (Resume to RAM content display.  Output follows RAM content
    SendCmd(SSD1306_NORMALDISPLAY);                 // 0xa6  Non-inverted display (0xA7 would invert

    SendCmd(SSD1306_DEACTIVATE_SCROLL);				// Stop previous scroll request
    SendCmd(SSD1306_DISPLAYON);						// Turn on display

    SendCmd(0xb0);       // Set GDRAM Page start back to 0
    SendCmd(0x00);       // Set Column low nibble to 0 (low 4 bits)
    SendCmd(0x10);       // Set Column high nibble to 0 (low 4 bits)

    
    gfColor = 1;
    gfFill = 0;
    gfFontId = 0;
    FONT_WIDTH = FONT_WIDTH0;
    FONT_HEIGHT = FONT_HEIGHT0; 
    gfFont2X = 0;  

    RawBuffer0[0] = 0x40;  // Set data bit of Control {C0,D/C,6'd0}
    RawBuffer1[0] = 0x40;  // Set data bit of Control {C0,D/C,6'd0} 

        // start the 2nd core to handle updating the display

    multicore_launch_core1(core1_entry);
    gfSetFill(0);  gfSetColor(1);  gfClearDisplay();
    multicore_fifo_push_blocking(SWAP_BUFFER_CLEAR_TO_0);  
    
}

void gfClearDisplay()
{
    uint16_t Addr;
    uint8_t *ptr = FrameBuffer;
 
    for(Addr=0;Addr<DISP_WIDTH*DISP_HEIGHT/8;Addr++) *ptr++ = 0;
}

void gfSetPixel(uint8_t X,uint8_t Y)
{
    uint16_t Addr;
    uint8_t Value;
    
    if(X>127 || Y>63){
       return;
    }
    Addr = X + DISP_WIDTH*(Y>>3);   
    Value = 1<<(Y&7);
    FrameBuffer[Addr] |= Value;
}

void gfClearPixel(uint8_t X,uint8_t Y)
{
    uint16_t Addr;
    uint8_t Value;
    
    if(X>127 || Y>63){ 
		return;
	}
    Addr = X + DISP_WIDTH*(Y>>3);
    Value = ~(1<<(Y&7));
    FrameBuffer[Addr] &= Value;
}

void gfSetColor(uint8_t c)
{
    gfColor = (c==0) ? 0 : 1;
}

void gfSetFill(uint8_t Solid)
{
     gfFill = (Solid==0) ? 0 : 1;
}

void gfHLine(uint8_t X,uint8_t Y,uint8_t Width)
{
    uint16_t Addr;
    uint8_t Value,Index;
    
    if(X+Width>DISP_WIDTH) Width = DISP_WIDTH-X;
    Addr = X + DISP_WIDTH*(Y>>3);
    if(gfColor!=0){
      Value = 1<<(Y&7);
      for(Index=0;Index<Width;Index++) FrameBuffer[Addr++] |= Value;
    }
    else{
      Value = ~(1<<(Y&7));
      for(Index=0;Index<Width;Index++) FrameBuffer[Addr++] &= Value;
    }
}

void gfVLine(uint8_t X,uint8_t Y,uint8_t Height)
{
    int Addr;
    uint8_t Value,Index,Offset;
    
    if(Y+Height>DISP_HEIGHT) Height = DISP_HEIGHT-Y;
    Addr = X + DISP_WIDTH*(Y>>3);
    Offset = Y & 7;
    if(gfColor!=0){
      Value = 0;
      for(Index=0;Index<Height;Index++){
          Value |= (1<<Offset);
          Offset++;
          if(Offset==8 || Index==Height-1){
              FrameBuffer[Addr] |= Value;
              Offset=0;
              Value = 0;
              Addr+=DISP_WIDTH;
          }
      }
    }
    else{
      Value = 0;
      for(Index=0;Index<Height;Index++){
          Value |= (1<<Offset);
          Offset++;
          if(Offset==8 || Index==Height-1){
              FrameBuffer[Addr] &= ~Value;
              Offset=0;
              Value = 0;
              Addr+=DISP_WIDTH;
          }
      }
   }
}

void gfRect(uint8_t X,uint8_t Y,uint8_t Width,uint8_t Height)
{
    uint8_t Index;
     
    if(Height==0 || Width==0) return;
    if(gfFill==0){
      gfHLine(X,Y,Width);
      gfHLine(X,Y+Height-1,Width);
      gfVLine(X,Y,Height);
      gfVLine(X+Width-1,Y,Height);
    }
    else{  // Solid fill
       for(Index=0;Index<Width;Index++){
         gfVLine(X+Index,Y,Height);
       }
    }
}

void gfSelectFont(uint8_t Id)
{
     if(Id>=2) return;
     
     gfFontId = Id;
     switch(gfFontId){
           case 0: FONT_WIDTH = FONT_WIDTH0;  FONT_HEIGHT=FONT_HEIGHT0;  break;
           case 1: FONT_WIDTH = FONT_WIDTH1;  FONT_HEIGHT=FONT_HEIGHT1;  break;
     }
}

void gfFontZoom(unsigned char Factor)
{
    gfFont2X = (Factor==2) ? 1 : 0;
} 

void gfPutc(unsigned char X,unsigned char Y,unsigned char c)
{
     unsigned int FontIndex=0,Addr;
     unsigned int Value16;
     signed char Bit;
     unsigned char Value,Fb,Index,Offset,Done,Offset2,Set,SaveY = Y;
     const unsigned char Lut1[] = {0x00,0x01,0x03,0x07,0x0f,0x1f,0x3f,0x7f};

     if(c>0x80) return;

     if(gfFontId!=0){
        if(c>0x20){
            FontIndex = (FONT_WIDTH-1)*(c-0x21);
        }
		for(Index=0;Index<FONT_WIDTH;Index++){
			if(c<=0x20 || Index==FONT_WIDTH-1){
				Value16 = 0;  // Make space after character
			}
			else{
				switch(gfFontId){
					case 1: Value16 = Font1[FontIndex+Index];   break;
					default: Value16 = 0;
				}
			} 
			Offset = 1<<(Y&7);
			Addr = X + DISP_WIDTH*(Y>>3);
			Fb = FrameBuffer[Addr];
			for(Bit=FONT_HEIGHT-2;Bit>=0;Bit--){
                Set = 0;
				if(((Value16>>Bit) & 1)==gfColor){
					Fb |= Offset;  Set = 1;
				}
				else{
					Fb &= ~Offset;
				}
                if(Offset==0x80) Offset = 1;
				else Offset = Offset<<1;
				Y++;
				if((Y&7)==0){  // New Address so dump out result and fetch new
					 FrameBuffer[Addr] = Fb;
                     if(gfFont2X){
                         FrameBuffer[Addr+1] = Fb;
                     }
					 Addr += DISP_WIDTH;
					 Fb = FrameBuffer[Addr];
				}
                
                if(gfFont2X){
                    if(Set){
                        Fb |= Offset;
                    }
                    else{
                        Fb &= ~Offset;
                    }
                    if(Offset==0x80) Offset = 1;
                    else Offset = Offset<<1;
                    Y++;
                    if((Y&7)==0){  // New Address so dump out result and fetch new
                        FrameBuffer[Addr] = Fb;
                        if(gfFont2X){
                            FrameBuffer[Addr+1] = Fb;
                        }
                        Addr += DISP_WIDTH;
                        Fb = FrameBuffer[Addr];
                    } 
                }    
			}
			  // Clear line below
			if(gfColor==0) Fb |= Offset;  else Fb &= ~Offset;        
			FrameBuffer[Addr] = Fb;
            if(gfFont2X){
                FrameBuffer[Addr+1] = Fb;
                X++;
            }
			Y=SaveY; 
            X++;
		}
    }
    else{
         FontIndex = 5*c;
         Addr = X + DISP_WIDTH*(Y>>3);
		 Offset = Y&7;
		 for(Index=0;Index<FONT_WIDTH;Index++){
			Value = Index==(FONT_WIDTH-1) ? 0 : Font0[FontIndex+Index];  // Make space after character
			Fb = FrameBuffer[Addr] & Lut1[Offset];
			Done = 0;  Offset2 = Offset;
			for(Bit=FONT_WIDTH;Done==0;Bit--){
				if(((Value>>Bit) & 1)==gfColor) Fb |= 1<<Offset2;  else Fb &= ~(1<<Offset2);
				Offset2++;
				if(Offset2==8 || Bit==0) Done = 1;
			}
			FrameBuffer[Addr] = Fb;
			if(Y<DISP_HEIGHT-FONT_HEIGHT && Bit>=0){ 
				Fb = FrameBuffer[Addr+DISP_WIDTH] & ~Lut1[Offset];
				Done = 0;  Offset2 = 0;
				for(;Done==0;Bit--){
				  if(((Value>>Bit) & 1)==gfColor) Fb |= 1<<Offset2;  else Fb &= ~(1<<Offset2);
				  Offset2++;
				  if(Bit & 0x80) Done = 1;
				}
				FrameBuffer[Addr+DISP_WIDTH] = Fb;
			}
			Addr++; 
		}
    }     
}

void gfPuts(unsigned char X,unsigned char Y,char s[])
{
    unsigned char i;
    
    if(Y>=DISP_HEIGHT) return;
    for(i=0;s[i];i++){ 
		gfPutc(X,Y,s[i]);
		X+=FONT_WIDTH;
        if(gfFont2X) X+=FONT_WIDTH;
		if(X>=DISP_WIDTH) return;
	} 
}

uint8_t gfGetFontWidth(void)
{
    uint8_t Size = FONT_WIDTH;
    if(gfFont2X) Size+=Size;
    return(Size);
}
uint8_t gfGetFontHeight(void)
{
    uint8_t Size = FONT_HEIGHT;
    if(gfFont2X) Size+=Size;
    return(Size);
}

// Some help from Bresenham
void gfLine(int x0,int y0,int x1,int y1)
{
    int dx, sx = x0<x1 ? 1 : -1;
    int dy, sy = y0<y1 ? 1 : -1; 
    int err, e2; 

    dx = x1-x0;  if(dx<0) dx = -dx;
    dy = y1-y0;  if(dy<0) dy = -dy;
    err = dx>dy ? dx : -dy;
		// -1/2 = 0 but -1 >> 1 is -1 so clean up the math
    if(err == -1) err = 0; else err = err>>1;

    if(gfColor==1){
        while(1){
            gfSetPixel(x0,y0);
            if (x0==x1 && y0==y1) break;
            e2 = err;
            if (e2 >-dx) { err -= dy; x0 += sx; }
            if (e2 < dy) { err += dx; y0 += sy; }   
        }
    }
    else{
        while(1){
            gfClearPixel(x0,y0);;
            if (x0==x1 && y0==y1) break;
            e2 = err;
            if (e2 >-dx) { err -= dy; x0 += sx; }
            if (e2 < dy) { err += dx; y0 += sy; }   
        }
    }
}

void _circlePixel(uint8_t xc,uint8_t yc,uint8_t x,uint8_t y)
{
    if(gfColor==0){
        gfClearPixel(xc+x,yc+y);
        gfClearPixel(xc+x,yc-y);
        gfClearPixel(xc-x,yc+y);
        gfClearPixel(xc-x,yc-y);
        gfClearPixel(xc+y,yc+x);
        gfClearPixel(xc+y,yc-x);
        gfClearPixel(xc-y,yc+x);
        gfClearPixel(xc-y,yc-x);
    }
    else{
        gfSetPixel(xc+x,yc+y);
        gfSetPixel(xc+x,yc-y);
        gfSetPixel(xc-x,yc+y);
        gfSetPixel(xc-x,yc-y);
        gfSetPixel(xc+y,yc+x);
        gfSetPixel(xc+y,yc-x);
        gfSetPixel(xc-y,yc+x);
        gfSetPixel(xc-y,yc-x);      
    }
}

void gfCircle(uint16_t xc,uint16_t yc,uint16_t r)
{
    int x,y;
    int p;

    x = 0;
    y = r;
    p = 3 - (r<<1);
    _circlePixel(xc,yc,x,y);
  
    while(x<y){
        if(p<0){
            x++;
            p += ((x<<2)+6);
        }
        else{
            x++;
            y--;
            p += (((x-y)<<2)+10);
        }
        _circlePixel(xc,yc,x,y);
    }
}

void gfCopyRect(uint8_t SrcX,uint8_t SrcY,uint8_t Width,uint8_t Height,uint8_t DstX,uint8_t DstY)
{
    uint8_t x,y,EndX,EndY,YD,Value;
    uint16_t AddrS,AddrD;
    
    if(Width==0 || Height==0) return;
    if(SrcX==DstX){ // Special case vertical scroll
        if(SrcY==DstY) return;
        if(SrcY>DstY){  //  Scroll up
            EndX = SrcX+Width;
            EndY = SrcY+Height;

            y = SrcY;
            for(x=SrcX;x<EndX;x++){
                YD = DstY;
                for(y=SrcY;y<EndY;y++){
                    AddrS = x + DISP_WIDTH*(y>>3);
                    AddrD = x + DISP_WIDTH*(YD>>3);
                    Value = (FrameBuffer[AddrS]>>(y&7)) & 1;
                    if(Value!=0)
                        FrameBuffer[AddrD] |= (1<<(YD&7));
                    else
                        FrameBuffer[AddrD] &= ~(1<<(YD&7));
                    YD++;
                }
            }
        }
    }
    else if(SrcY==DstY){ // Special case horizontal scroll
        if(SrcX==DstX) return;
    }
    else{
    }
}

static uint8_t TermX = 0;
static uint8_t TermY = 0;

void TerminalInit()
{
    static int First = 1;

    if(First){
        multicore_fifo_pop_blocking();  // wait for swap and clear to finish from gfDisplayOLEDInitMC() 
        First = 0;
    }
    FrameBuffer = DisplayBuffer;
    TermX = 0;  TermY = 0;
    gfClearDisplay();
}

void TerminalScroll()
{
    uint8_t SaveFill,SaveColor;
    
    SaveFill = gfFill;  SaveColor = gfColor;
    
    gfCopyRect(0,FONT_HEIGHT,DISP_WIDTH,DISP_HEIGHT-FONT_HEIGHT,0,0);
    gfSetFill(1);  gfSetColor(0);
    gfRect(0,DISP_HEIGHT-FONT_HEIGHT,DISP_WIDTH,FONT_HEIGHT);
    gfSetFill(SaveFill);  gfSetColor(SaveColor); 
}

void TerminalSetCursor(uint8_t X, uint8_t Y)
{
     TermX = X*FONT_WIDTH;
     if(TermX+FONT_WIDTH>=DISP_WIDTH) TermX = DISP_WIDTH-FONT_WIDTH;
     TermY = Y*FONT_HEIGHT;
     if(TermY+FONT_HEIGHT>DISP_HEIGHT) TermY = DISP_HEIGHT-FONT_HEIGHT;
}

void TerminalPuts(char s[])
{
    uint8_t i;
    char c;

    
    for(i=0;s[i];i++){
        c = s[i];
        if(c>=0x20 && c<=0x7f){
            if(TermX+FONT_WIDTH>=DISP_WIDTH){
                TermX = 0;  TermY+=FONT_HEIGHT;
                if(TermY+FONT_HEIGHT>DISP_HEIGHT){
                    TerminalScroll();
                    TermY -= FONT_HEIGHT;
                }
            }
            gfPutc(TermX,TermY,c);  TermX+=FONT_WIDTH;
        }
        else{
            switch(c){
                 case '\n':
                     TermX = 0;  TermY+=FONT_HEIGHT;
                     if(TermY+FONT_HEIGHT>DISP_HEIGHT){
                         TerminalScroll();
                         TermY -= FONT_HEIGHT;
                     } 
                     break;
            }
        }
    }
    gfUpdateDisplay(0);
}
